# C-project1
# Project 1





### 1. 概述

本次project为矩阵乘法，报告分为四个部分：基本矩阵运算及注意点，大规模矩阵的优化，优化中出现的问题与分析及可以进行的进一步优化。

### 2. 控制台读入

#define input开启控制台读入

控制台读入矩阵有三个注意点：

一是判断每行的个数是否相等，每行个数、读到行结束已读入的所有个数分别用一个临时变量curColumn和矩阵类（struct）的Count存储，判断row = count/curColumn 是否成立即可。判断第一个矩阵的列于第二个矩阵的行是否相等。

二是什么时候分配内存，用一维数组模拟矩阵，每读入10000个增加内存，此方法避免提前分配过多内存而导致的浪费。

三是判断读入的字符是否是数字，先以字符串方式暂存，判断合法后转化为浮点型。为保证程序的鲁棒性，该程序可以跳过空格，以end为结束标志。

### 3. 优化（数据规模为1000*1000）

#### 0. 三重循环无优化

为测试方便，矩阵规模设为1000规模，以下均为1000规模矩阵

![image-20201115223605974](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115223605974.png)

#### Ⅰ. O3

开启O3编译直接从7000ms跃升到1600ms，开始起飞！

![image-20201115223233023](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115223233023.png)

#### Ⅱ. AVX2指令集

读入一个数据虽然耗时不明显，但一次读一个数据，10000*10000的读入耗时就将会十分巨大，想要提高速度, 就要让一次读取的数据能尽可能多的被用于计算，由此可以联想到使用指令集。

指令集技术即为同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术，指令集可以大大加速程序运行速度，指令集可以使CPU接受指令，完成比如合并打包计算，输出结果，每条指令对应着几条汇编语言，编译后为可以被CPU识别的机器码。

在本程序中采用256位，每8个数打包，_ loadu _可以自动对齐，支持灵活的不对齐内存地址访问，不必限制矩阵为8的倍数,这里注意，因为数据打包是相邻内存单元，故矩阵b需要经过转置才能得到正确答案。理论上可以优化8倍，但这和处理器的架构有关，大多数情况下并不能直接优化8倍，在实际中，优化了3倍。



![image-20201115224008063](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115224008063.png)



#### Ⅲ. 多线程问题

该程序使用OpenMP，OpenMP共享内存，它依赖private和shared指令来区分各个线程在并行区计算的数据是否共享（这里有一个小秘密，即课上讲的“数据冲突”）。然后需要等待并行计算区的语句全都执行完，回到之前的串行程序。

原理图如下

![image-20201115232205378](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115232205378.png)

首先用函数omp_get_num_thread 获知计算机当前并行计算的线程数。这里想到一个问题，设置线程为1，不就是串行计算吗？那与串行计算相比效率如何？

![image-20201115231936428](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115231936428.png)

可以惊奇的看到用1线程的并行比串行慢了许多！经过查阅资料，我总结为线程非但没有进行计算任务的分配，还在指令下进行并行运算，所以线程间不起作用的并行过程拖延了时间。

- 数据冲突问题 

  之前实践过，在向量点积中运用多线程会出现三个不同的答案，这是因为数据冲突了，对于共享内存的模型，比如初始有变量a = 2,线程A要让a+1,线程B要让a*=2。多个进程/线程同时访问某个数据、内存，使得数据发生改变，就发生了数据冲突！

- 线程同步

  有的线程比较慢，有的比较快，为了在某一时刻使得线程达到同样的状态，叫做线程同步，对于共享内的模型，我们控制数据的访问从而达到线程同步。

- 解决办法

  解决数据冲突的办法，可以用栅栏命令，或section让线程分区，或者控制数据访问权限等方法，这里我采用critical创建临界区。解决了这一棘手问题。下面看一下优化效果！

  ![image-20201115233353155](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115233353155.png)

结果还是非常的amazing，优化到了175ms，比之前的7000ms优化了40倍之多！

### 4. 遇到的problem 

一维数组存储矩阵，如图：

![image-20201115234112321](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115234112321.png)



比二维数组直接存储慢了整整10倍！这一直令我百思不得其解，唯一能想到的解释是一维数组寻址时耗费了很多的时间，但很难相信会夸张到慢了10倍...

### 4*最终结果

![image-20201115235138817](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115235138817.png)

10000*10000最终优化结果！188s.

### 5. OpenBlas

![image-20201115235237363](C:\Users\tianyinxi\AppData\Roaming\Typora\typora-user-images\image-20201115235237363.png)

10000*10000数据openblas用时2分钟，比我快大概50秒，运算结果相同

### 6. 其他优化可能...

#### Ⅰ. MPI:

MPI：与OpenMp相反，MPI核心是不共享内存，并行计算依赖于消息传递，只有消息传递各个进程间才能共享数据。只有共享数据才能做到并行计算。因此，MPI的计算模式是所有进程运行同样的程序，这个程度都是一样的，也都是完整的。如何确定消息的收发方依赖于进程的秩。

#### Ⅱ .cuda

是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题，用来优化大规模矩阵运算是不错的选择，但因为时间关系，这两个都没有在本程序中实现，也是本次project小小的遗憾。
